# Nest.js API 샘플

구매 상담 정보를 받아서 저장하고, 관리자 페이지에서 검색/필터 조회하는 API 서버 예시.

## ✅ 주요 구현 요약

- **도메인 기반 설계**: `Inquiry`, `Business` 등 명확한 책임 단위로 기능을 분리하여 유지보수성과 확장성을 고려
- **입력 유효성 보장**: 전화번호에 대한 정규식 기반 정교한 검증 + 단위 테스트 작성
- **Swagger 문서화 완료**: 모든 API 요청/응답 스펙 명시, 테스트 가능한 Swagger UI 자동 생성
- **쿼리 최적화**: `QueryBuilder` 및 `between` 조건을 활용한 필터 검색, 추후 인덱싱 고려 가능
- **배치 + 큐 기반 처리**: 공공 API 조회를 `Bull Queue`로 분산 처리하여 재시도 및 실패 추적 가능, 시스템 확장 고려
- **보안 고려된 설정 관리**: API 키 등 민감 정보는 암호화된 `yaml`에서 로드 → 런타임 복호화
- **실행 주기 기반 상태 관리**: 마지막 상태 조회 시점 기준 `intervalDays` 로직으로 과도한 요청 방지

## 🧭 구현 세부내용

### 🛠 개발 환경 및 실행 방법

- Node.js: `v20.19.2` (`.nvmrc` 사용)

```bash
nvm use                 # or nvm install
```

- 코드 스타일: Prettier + ESLint 설정 포함 (`pnpm format`, `pnpm lint`)

### ⚠️ MacOS(Apple Silicon)에서의 SQLite 빌드 주의사항

Apple Silicon 환경(macOS ARM64)에서는 sqlite3가 사전 빌드된 바이너리를 제공하지 않는 경우가 있어, 수동 빌드가 필요합니다.
저의 로컬 환경에서는 아래와 같은 방식으로 빌드를 수행해 pnpm schema:generate 실행 시 발생하는 Could not locate the bindings file. 에러를 해결했습니다.

```bash
cd node_modules/sqlite3

# 바이너리 수동 빌드
node-gyp rebuild --build-from-source --arch=arm64

# 노드 바인딩
mkdir -p lib/binding/node-v115-darwin-arm64
cp build/Release/node_sqlite3.node lib/binding/node-v115-darwin-arm64/
```

협업 상황을 가정해 위 작업을 자동화한 postinstall 스크립트를 작성해 두었습니다. `pnpm install` 실행 시 자동으로 동작합니다.
스크립트는 `scripts/sqlite3-postinstall.ts`에 있습니다.

### Yaml을 이용한 설정파일 구성 및 암호화

- `.yaml` 파일 내 민감정보는 `cipher::` 접두어와 함께 `AES-256` 방식으로 **암호화**하여 저장합니다. `.env` 파일에는 복호화에 사용되는 `APP_SECRET`과 실행 환경을 나타내는 `NODE_ENV`만을 **최소한으로 정의**합니다.
- 실행 시점에 `.env` 파일의 `APP_SECRET` 환경변수를 활용해 자동 복호화가 수행됩니다.
- `.yaml`과 `.env` 모두 **환경별(development, production 등)로 분리**하여 사용할 수 있도록 구성했습니다.
- `.yaml` 형식은 Kubernetes, Docker Compose 등과 구조적으로 호환되어, 추후 **CI/CD 파이프라인 및 외부 설정 관리 도구 연계**에 유리합니다.
- 새로운 민감정보를 암호화할 경우를 대비해 `scripts/encrypt.ts` 유틸 스크립트를 제공하며, 아래와 같이 사용할 수 있습니다.
  ```bash
  pnpm ts-node scripts/encrypt.ts "what-you-want-to-encrypt"
  ```

### DB 스키마 및 엔티티/리포지토리 설명

#### 스키마 설계 기준

- `상담`과 `비즈니스`를 분리합니다.
  - 요청받은 기능의 시작점은 상담이지만, 결국 **상담의 목적이 되는 가장 중요한 도메인은 비즈니스**라고 생각했습니다.
    - 이 시스템은 단순한 일회성 문의 처리가 아닌 장기적인 고객관계를 위한 수단입니다.
    - 따라서 상담 정보를 저장하는 테이블과 비즈니스 정보를 저장하는 테이블의 분리가 필요하다고 판단했습니다.
  - 이 구조는 다음과 같은 장점이 있습니다.
    - 동일 사업자의 반복 문의를 통합 관리할 수 있습니다.
    - 유입 고객의 사업적 가치 평가 및 우선순위 지정이 가능합니다.
    - 다양한 고객 정보를 바탕으로 고객 세분화 및 추적이 가능한 CRM 시스템 확장의 기반이 될 수 있습니다.
- `데이터 무결성 확보`에 주력합니다.
  - 단순한 데이터 저장이 아닌, 향후 분석과 재활용을 염두에 두고 **정합성 높은 구조**를 만들고자 노력했습니다.
    - 예를 들어, 상담 내용에 관한 타임스탬프가 일관성을 유지할 수 있도록 별도의 유효성 검증 로직을 적용했습니다.
  - 대부분의 고객 데이터가 비정형적 특성을 지니므로 이런 대상에는 유연하게 대응하되, 제어할 수 있는 범위 내에서 가능한 정형화해 관리할 수 있도록 구성했습니다.
    - 정확성과 신뢰성을 높이는 기초데이터를 확보해 **데이터 기반 의사결정을 지원**합니다.
- 표현과 저장을 분리해 `사업자 번호`와 `휴대폰 번호`는 숫자만 저장합니다.
  - 형식은 표현의 문제이기 때문에 저장 시 제거했습니다. 하이픈(-) 등은 표현(뷰)에서만 사용하는 포맷이므로, DB에는 숫자만 저장하고 프론트 또는 출력 시 포맷팅 처리합니다.
  - **데이터 입력 시 사용자마다 다른 형식으로 입력할 수 있으므로**, 숫자만 저장함으로써 **데이터 일관성을 확보**하고, **검색 및 비교 로직을 단순화**할 수 있습니다.
  - 향후 **정규화 및 표준화에 유리해 시스템 확장성에 도움**이 됩니다. 예를 들어 국제번호(+82) 등을 도입할 때도 상대적으로 수월하게 적용할 수 있습니다.
  - **불필요한 저장공간을 절약**합니다.

이러한 설계 기준은 단기적 개발 편의성보다는, 중장기적 데이터 활용 가능성과 시스템 확장을 염두에 둔 선택입니다. 이는 향후 분석, 마케팅, 고객 세분화 전략 등 다양한 방향으로의 확장을 자연스럽게 뒷받침합니다.

#### 엔티티 설명

- `BusinessEntity`
  - 실제 사업체 정보를 나타냅니다.
  - 상담 요청을 통해 전달받은 사업자 번호가 있는 경우 business 테이블의 row를 생성합니다. 고객 관리와 데이터 분석을 위해 이렇게 설계했습니다.
  - 동일한 사업자에 대해 여러 건의 상담 요청이 들어올 수 있다고 판단해 Inquiry 테이블과 1:N 관계를 이루도록 설계했습니다.
  - status(`EBusinessStatus`) 중 하나인 `UNKNOWN`은 사업자번호 형식은 유효하지만 공공 API 조회에서 확인되지 않은 경우에 설정됩니다.
    - `UNKNOWN` 활용 목적
      - 재검증 대상 필터링: 주기적 배치 작업을 통한 재조회 대상으로 분류
      - 관리자페이지 경고/확인 노출: 운영자가 주의 깊게 검토해야 할 항목으로 표시
      - 허위 입력 탐지 및 리포트: 반복적/비정상 입력에 대한 이상 탐지 및 추적
- `InquiryEntity`
  - 사용자가 남긴 상담 요청입니다. `business`는 선택적으로 연결됩니다.
  - 상담 요청을 기준으로 휴대전화 번호와 업종, 마케팅 동의 여부를 기록합니다.
  - 업종(`industry`)은 실제 사업자가 확인되지 않더라도 입력되므로 `InquiryEntity`에서 관리합니다.
    - 향후 사업자번호가 등록되더라도 원문의 업종 선택 내역을 유지할 수 있습니다.
  - 마케팅 동의 여부를 BusinessEntity에서 기재할까 고민했으나, 개인정보 보호와 사업자와 상담 요청자가 다를 경우를 고려해 그대로 두었습니다.
  - `source` 필드의 경우 GA 등의 도구로 유입 경로를 기재할 경우 사용할 수 있도록 추가해뒀습니다.
- `ConsultLogEntity`

  - 상담 이력입니다. `inquiry`에 연결되어 있고 상태별로 다른 타임스탬프(`scheduledAt`, `completedAt`, `canceledAt`)를 가집니다.
    - 상태에 따라 다음 필드 중 하나 이상이 채워집니다:
      - `scheduledAt`: 상담이 예약된 경우 (`SCHEDULED`)
      - `completedAt`: 상담이 완료된 경우 (`COMPLETED`)
      - `canceledAt`: 상담이 취소된 경우 (`CANCELED`)
    - 여러 상태를 가질 수 있으므로, `status` 필드와 조합하여 사용합니다.
    - 타임스탬프 필드는 인덱싱되어 상태별 이력 조회 및 통계 수집에 활용됩니다.
  - `consultantName`은 현재 자유 입력 필드로 구성되어 있지만, 추후 사내 사용자 DB가 연동되면 관계형으로 전환 가능합니다.
  - 동일한 상담 요청에 대해 여러 건의 상담이 가능할 것으로 판단해 Inquiry 테이블과 1:N 관계를 이루도록 설계했습니다.

- 관계: **Business ↔ Inquiry ↔ ConsultLog**

#### 리포지토리

- 본 프로젝트에서는 MikroORM의 `EntityManager(em)`를 직접 주입받아 사용합니다.
  - 트랜잭션 컨텍스트 내에서 여러 엔티티를 일괄 처리할 수 있어 유연한 설계를 가능하게 합니다.
  - MikroORM v6에서는 `EntityRepository`의 `persist`, `flush` 계열 메서드가 `제거`되었으며, 이로 인해 entity 저장/삭제 등은 `EntityManager를 통해 수행하는 방식이 권장`됩니다.
    - 출처: [MikroORM v6 Migration Guide](https://mikro-orm.io/docs/migration/v6#removed-methods-from-entityrepository)

### 고부하 처리 고려

- 현재 API는 단건 요청을 기준으로 동기적으로 DB에 저장하는 구조입니다. 하지만 실서비스 환경에서는 다음과 같은 상황이 발생할 수 있으므로, **향후 확장을 고려한 구조 설계**가 필요합니다.
  - 예상 상황
    - 단기간 내 대량의 구매상담 요청 유입
    - 공공 데이터 API 과다 호출 방지(단순 정기조회라면 스케쥴러로 충분하지만, 다양한 이벤트 발생과 엮거나 통합 관리하고자 할 때)
    - 내부 관리 시스템과의 비동기 연동

#### 확장안

- Kafka 기반 비동기 이벤트 처리 구조
  - **이벤트 발행 구조 도입**  
    구매상담 요청 시, DB 저장 대신 Kafka Topic (`inquiry-topic`)에 메시지를 발행합니다.
  - **비동기 컨슈머 도입**  
    별도의 컨슈머 서비스에서 Kafka 메시지를 수신하여 DB에 저장함으로써 API 처리 속도는 개선하고, 저장 로직은 분리하여 안정성 확보합니다.
  - **배치 로직 분리**  
    사업자 상태 업데이트 등 외부 API 연동 또한 Kafka를 통해 처리할 수 있으며, 이는 병렬 처리 및 재시도 전략 구성에 유리합니다.
- Redis 큐/버퍼 기반 구조
  - 단순한 유입량 버퍼링이 필요한 경우, Redis 큐를 활용해 요청을 임시 저장하고 일정 단위로 일괄 처리하는 방식도 고려 가능합니다.
  - DB와의 직접적인 연동을 지연시켜 일시적 트래픽 과부하를 완화할 수 있습니다.

### 상담 리스트 조회 쿼리 설계

#### `QueryBuilder` 사용

- 단순 `find()` 또는 `findAll()`메서드는 동적 조건이 많은 경우 가독성이나 유지보수 측면에서 불리합니다.
- `QueryBuilder`를 사용하면 조건, 정렬, JOIN 등 세부 쿼리 로직에 대한 제어권을 확보할 수 있으며, 대용량 데이터 환경에서도 성능 최적화를 도모할 수 있습니다.
- 또한, 추후 필터 조건의 추가나 정렬 방식 변경이 발생해도 구조적으로 유연하게 대응할 수 있습니다.

#### 필터 조건 배치 순서 설계 이유

```ts
if (fromDate && toDate) {
  qb.andWhere({ createdAt: { $gte: ..., $lte: ... } });
}
if (status) {
  qb.andWhere({ status });
}
if (phoneNumber) {
  qb.andWhere({ phoneNumber });
}
```

- `createdAt` (1순위)
  - 기본 정렬이 `createdAt DESC`이므로, 인덱스 선두에 배치되어야 성능상 이점이 크다고 판단했습니다.
  - 대량 데이터에서 `ORDER BY`는 큰 **부하**를 유발할 수 있으므로, 먼저 `createdAt`으로 범위를 좁히는 것이 효율적입니다.
  - 실제 서비스에서도 기간 기반 조회가 **가장 일반적인 필터 조건**으로 사용됩니다.
- `status` (2순위)
  - 카디널리티는 낮지만, **조회 빈도가 높은 조건**입니다.
  - 특히 `createdAt`과의 복합 인덱스를 통해 **날짜 조건 필터 이후 추가적인 좁힘**에 기여할 수 있습니다.
- `phoneNumber` (3순위):
  - 특정 사용자를 찾는 고유 필터지만, 일반적으로는 다른 조건과 함께 사용되며 인덱스 효율이 상대적으로 낮습니다.
  - 정렬이나 범위 조건과 결합 시 성능에 영향을 줄 수 있어 가장 마지막에 배치하는 것이 합리적이라 판단했습니다.

### `/internal/:id` 상담 상세조회 추가 구현

- 관리자 페이지라는 점을 고려했을 때, 실제 비즈니스 상황에서는 리스트에서 특정 상담의 상세 내용을 확인하는 기능이 필수입니다.
- 따라서 요구사항에 명시되어 있지 않지만, 목록 조회 기능과 짝을 이루는 형태로 단건 상세 조회 API를 구현했습니다.
  (`create`, `update` 기능도 유사한 맥락에서 자연스럽게 확장 가능하며, 필요에 따라 손쉽게 추가할 수 있도록 구조화했습니다.)

### 공공 API 요청

#### 배치 스케쥴 설계

- 조건

  - 1회 요청당 최대 100건
  - 1일 최대 1,000,000 요청 가능

- 설계안

  - 표현식: `*/5 0-7 * * *`
  - 실행 간격: 매일 0시부터 7시까지 5분 간격 실행
  - 일일 실행 횟수: 8시간 × 12회/시간 = **96회**
  - 총 처리량: 9,600건/일 × 7일 = **67,200건/주기** (단일 인스턴스 기준)
  - 상태 조회 주기는 config 파일(`.yaml`)의 `intervalDays`(기본 7일) 기준으로 수행

- 스케쥴 설계 의도

  - 공공 API의 호출 허용 한도(일 100만 건)를 감안해, 과도한 호출 없이 안정적인 커버리지를 확보할 수 있도록 설계했습니다.
  - 야간 시간대 집중 실행을 통해 사용자 활동이 적고 외부 시스템 부하가 낮은 시간대를 활용합니다.

#### `Bull Queue` 도입

- 초기 사업자 등록 시 정보 검증이 누락되었거나, API 요청 중 오류가 발생한 경우를 처리하기 위해 `Bull Queue`를 도입하였습니다.
- 각 배치 실행 시 조회 대상 사업자 리스트를 Job으로 큐에 등록하고, `@Processor`에서 공공 API 요청 및 상태 업데이트를 수행합니다.
- 실패한 Job은 `config.yaml`의 `retry.max-attempts` 설정에 따라 자동 재시도되며, 실패 이력 또한 추적할 수 있습니다.
- 이를 통해 전체 프로세스의 안정성, 확장성, 오류 복원력이 크게 향상됩니다.
